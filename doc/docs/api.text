API
===

`DB_Adapter` предоставляет очень простой и лаконичный интерфейс для обращения к СУБД.
В его разработке мы руководствуемся двумя принципами:

*   **Выполнение запроса и получение результата объединены в одну операцию**
    То есть, не существует промежуточного объекта или ресурса _результата_,
    вы сразу получаете то, что нужно

*   **Представление результата определяется выбранным методом запроса**
    Например, `fetchRow()` возвращает строку таблицы, как ассоциативный массив, `fetchCell()`
    &mdash; содержимое ячейки в виде скаляра и т.д.


Краткий обзор
-------------

Интерфейс библиотеки состоит из методов, которые определяют, в каком виде будет представлен результат
выполнения запроса.

<pre><code>// Выборка всего результата в виде списка ассоциативных массивов
mixed DB_Adapter_Generic_DB::<a href="/docs/api/fetchAll/">fetchAll</a>(string $query [, $arg1 [, $arg2 ... ]])
</code></pre>

<pre><code>// Выборка первой строки результата в виде ассоциативного массива
hash DB_Adapter_Generic_DB::<a href="/docs/api/fetchRow/">fetchRow</a>(string $query [, $arg1 [, $arg2 ... ]])
</code></pre>

<pre><code>// Выборка результата в виде "столбца"
array DB_Adapter_Generic_DB::<a href="/docs/api/fetchCol/">fetchCol</a>(string $query [, $arg1 [, $arg2 ... ]])
</code></pre>

<pre><code>// Выборка скалярного результата запроса (одной ячейки)
scalar DB_Adapter_Generic_DB::<a href="/docs/api/fetchCell/">fetchCell</a>(string $query [, $arg1 [, $arg2 ... ]])
</code></pre>

<pre><code>// Выборка ограниченного результата в виде списка ассоциативных массивов
// с занесением общего числа записей в переменную $total
mixed DB_Adapter_Generic_DB::<a href="/docs/api/fetchPage/">fetchPage</a>(int& $total, string $query [, $arg1 [, $arg2 ... ]])
</code></pre>

Как вы видите, все методы принимают список аргументов переменной длины. Аргумент `$query` представляет
собой текст запроса в виде строки, а дополнительные аргументы нужны для раскрытия _плейсхолдеров_.

Рассмотрим следующий пример:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// получаем список ID пользователей, которые нас НЕ интересуют
$uids = getBadUserIds();

$usersData = $DB->fetchAll("

    SELECT * FROM tbl
    WHERE id NOT IN (?a)",

    $uids
);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Заметьте, что в тексте запроса мы использовали не только привычный синтаксис SQL, но и
специальный синтаксис макроподстановок `DB_Adapter`. В данном случае, это был [списковый плейсхолдер](/docs/placeholders/a/)
`?a`, который разворачивает список в строку из перечисленных через запятую экранированных значений.

Комментарии
-----------

Заметьте, `DB_Adapter` помогает лишь обратится к СУБД и представить результат этого обращения
в нужном виде. Всё остальное &mdash; это всё тот же SQL, плюс набор удобных плейсхолдеров, макросов
и т.д. Мы не считаем правильным абстрагироваться от SQL или приводить различные диалекты к общему
знаменателю.

SQL &mdash; это прекрасный язык, на котором приятно писать и читать запросы, а различные диалекты
создавались для того, чтобы можно было использовать архитектурные особенности конкретной СУБД всё
в той же интуитивно понятно модели.